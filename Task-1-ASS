;====================================================================
; Main.asm file generated by New Project wizard
;
; Created:   p√° 2 28 2014
; Processor: ATmega168
; Compiler:  AVRASM (Proteus)
;====================================================================

;====================================================================
; DEFINITIONS
;====================================================================

;====================================================================
; VARIABLES
;====================================================================

;====================================================================
; RESET and INTERRUPT VECTORS
;====================================================================

      ; Reset Vector
      rjmp  Start

;====================================================================
; CODE SEGMENT
;====================================================================

Start:
; 
; First ASM Programm for the Evaluation Board
;
; Example of LED blinking program for ATmega168
;
; LED cathode connected to PORT D bit 6, anode to +Ucc,
; 3 switches S1, S2, S3 connected to PORT C bit 1, 2, 3 (PC1, PC2, PC3),
; connect JP1 to GND
; 

; microcomputer hardware definition
; it is necessary to say the assembler something about our HW:


;normally we use the complete definition from the definition file:
;	.INCLUDE "m168def.inc"

	.equ LED = 6	;bit of the output port C with LED
	.equ S1 = 4		;bit of the input port D with Switch1
	.equ SEG = 5


	
; Initialization
	EOR R0, R0
	OUT DDRC, R0
	OUT DDRB, R0
	OUT PORTB, R0
	OUT PORTC, R0
	
	
	
	ldi R16, 254
	out DDRB, R16
	;sbi DDRB, LED	;Set Bit Immediately - LED pin is output
;	cbi PORTD, LED	;LED ON (LED is ON when log. 0 on this bit) - not necessary, log. 0 from AVR initialization
	;sbi DDRC, 5
	


;	cbi DDRC, S1	;Clear Bit Imm. - not necessary, log. 0 from AVR initialization
	;sbi PORTC, S1	;pull-up resistor on the switch input

;
; Main program start
;
; blinking LED
;
;
; modification:
; when S1 pressed then LED continuously ON until S1 released
;    (uncomment the first two lines)
;
; To do: when S2 pressed then LED continuously OFF until S2 released
;


	
Main: 
	sbi DDRC, 5  ;configure pin4 as output, 4 controls left display
	;sbi DDRC, 5   ;configure pin5 as output
	cbi PORTC, 5 ;cbi = ON display, 4 = left
	;sbi PORTC, 5  ;sbi = OFF display

	ldi R17,255 ; OFF to all 7 segments of the display
	out PORTB, R17

	cbi PORTB, 1	;segment OFF
	rcall Delay_06s	;relative call (not very far) to Delay 0,5 s
	sbi PORTB, 1	;segment ON
	rcall Delay_06s	
	
	cbi PORTB, 2	;segment OFF
	rcall Delay_06s	;relative call (not very far) to Delay 0,5 s
	sbi PORTB, 2	;segment ON
	rcall Delay_06s	

	cbi PORTB, 3	;segment OFF
	rcall Delay_06s	;relative call (not very far) to Delay 0,5 s
	sbi PORTB, 3	;segment ON
	rcall Delay_06s	

	cbi PORTB, 4	;segment OFF
	rcall Delay_06s	;relative call (not very far) to Delay 0,5 s
	sbi PORTB, 4	;segment ON
	rcall Delay_06s	

	cbi PORTB, 5	;segment OFF
	rcall Delay_06s	;relative call (not very far) to Delay 0,5 s
	sbi PORTB, 5	;segment ON
	rcall Delay_06s	

	cbi PORTB, 6	;segment OFF
	rcall Delay_06s	;relative call (not very far) to Delay 0,5 s
	sbi PORTB, 6	;segment ON
	rcall Delay_06s	


	rjmp Main	;loop to start


; Delay loop cca 0,6 s for 1 MHz AVR clock:
;
; based on incrementing/decrementing of the register until 0
;
Delay_06s:
	ldi R16, 3	;prepare for 3 loops of 256x256 loops (1 Clk)
Delay:
  	inc R1		;256 incrementing of R1 (1 Clk)
	brne Delay	;Branch if Not Equal - until 0, then go to R2 (1/2 Clk)
	inc R2		;repeat it 256x (1 Clk)
	brne Delay	; (1/2 Clk)
	dec R16		;and that all do 3x (1 Clk)
	brne Delay	; (1/2 Clk)
	ret			;return after 3+4+(256*256*3+256*3+3)*3-256*3-3 Clk pulses. Why?

;====================================================================
